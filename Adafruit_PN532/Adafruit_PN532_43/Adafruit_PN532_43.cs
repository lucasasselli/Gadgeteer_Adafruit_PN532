using System.Threading;
using Microsoft.SPOT.Hardware;
using GTM = Gadgeteer.Modules;

namespace Gadgeteer.Modules.Luca_Sasselli
{
    /// <summary>
    ///     A module for Adafruit PN532 NFC for Microsoft .NET Gadgeteer
    /// </summary>
    public class Adafruit_PN532 : Module
    {
        /// <summary></summary>
        public delegate void NfcEventHandler(string uid);

        /*
         * PN532 CONSTANTS
         */

        // Data
        private const byte Preamble = 0x00;
        private const byte Startcode = 0xFF;
        private const byte Postamble = 0x00;
        private const byte HostToPn532 = 0xD4;

        // Commands
        private const byte CommandGetfirmwareversion = 0x02;
        private const byte CommandReadgpio = 0x0C;
        private const byte CommandWritegpio = 0x0E;
        private const byte CommandSamconfiguration = 0x14;
        private const byte CommandInlistpassivetarget = 0x4A;

        // SPI
        private const byte SpiStatread = 0x02;
        private const byte SpiDatawrite = 0x01;
        private const byte SpiDataread = 0x03;
        private const byte SpiReady = 0x01;

        // Internal
        private const byte MifareIso14443A = 0x00;

        // Chip select constants
        private const int SpiCsPin = 6;
        private const bool SpiCsActiveState = false;
        private const uint SpiCsSetupTime = 2; // ms
        private const uint SpiCsHoldTime = 2; // ms

        // Clock constants
        private const bool SpiClkIdleState = false;
        private const bool SpiClkEdgeRise = true;
        private const uint SpiClkFreq = 1; // kHz

        // Responses
        private static readonly byte[] Ack = {0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00};
        private static readonly byte[] FvHead = {0x00, 0xFF, 0x06, 0xFA, 0xD5, 0x03};

        private bool _running;

        // Main objects
        private readonly SPI _spi;

        private int _threadPeriod;
        private Thread _threadScan;
        private int _threadTimeout;
        private readonly ManualResetEvent _threadWaitForStop;

        // Note: A constructor summary is auto-generated by the doc builder.
        /// <summary></summary>
        /// <param name="socketNumber">Socket number</param>
        public Adafruit_PN532(int socketNumber)
        {
            // Get socket
            var socket = Socket.GetSocket(socketNumber, true, this, null);
            var spiModule = socket.SPIModule;
            var chipSelectPort = socket.CpuPins[SpiCsPin];

            // Configure SPI
            var spiConfig = new SPI.Configuration(
                chipSelectPort,
                SpiCsActiveState,
                SpiCsSetupTime,
                SpiCsHoldTime,
                SpiClkIdleState,
                SpiClkEdgeRise,
                SpiClkFreq,
                spiModule);

            _spi = new SPI(spiConfig);

            _threadWaitForStop = new ManualResetEvent(false);
        }

        // Event handling/threading
        /// <summary>Event handler for TAG listener</summary>
        public event NfcEventHandler TagFound;

        /// <summary>Initializes NFC module</summary>
        public bool Init()
        {
            DebugOnly.Print("Starting NFC module...");

            // This is needed for synchronization
            byte[] packet = {CommandGetfirmwareversion};
            SendCommandCheckAck(packet);

            // Wait some time
            Thread.Sleep(1000);

            // Configure safe access manager
            if (SamConfig())
                return false;

            return false;
        }

        /// <summary>Starts listening for a new NFC card</summary>
        /// <param name="period">Period of the polling</param>
        /// <param name="timeout">Timeout of the scan</param>
        public void StartScan(int period, int timeout)
        {
            _running = true;
            _threadPeriod = period;
            _threadTimeout = timeout;

            if (_threadScan != null)
            {
                if (!_threadScan.IsAlive)
                {
                    // Thread was killed
                    _threadScan = new Thread(Scan);
                    _threadScan.Start();
                }
                else
                {
                    // Thread is running or sleeping
                    _threadWaitForStop.Set();
                }
            }
            else
            {
                // Thread wasn't yet started
                _threadScan = new Thread(Scan);
                _threadScan.Start();
            }
        }

        /// <summary>Stop listening for a new NFC card</summary>
        public void StopScan()
        {
            _running = false;
            _threadWaitForStop.Set();
        }

        /// <summary>Returns current firmware version</summary>
        public uint GetFirmwareVersion()
        {
            // Request firmware version
            byte[] packet = {CommandGetfirmwareversion};
            if (!SendCommandCheckAck(packet))
                return 0;

            // Read response
            var response = ReadData(12);

            // Extract firmware version
            var header = Utility.ExtractRangeFromArray(response, 0, 6);

            if (!Common.CompareByteArray(header, FvHead))
                DebugOnly.Print("Response is not firmware!");

            var version = (Utility.ExtractValueFromArray(response, 6, 4) >> 8) & 0xFF;

            return version;
        }

        private bool SendCommandCheckAck(byte[] cmd, int timeout = 1000)
        {
            // Write the command
            WriteCommand(cmd);

            // Wait for chip to say its ready!
            if (!WaitReady(timeout))
                return false;

            // Read acknowledgement
            if (!ReadAck())
            {
                DebugOnly.Print("No ACK frame received!");
                return false;
            }

            DebugOnly.Print("PN532 acknowledged the command!");

            return true;
        }

        private void Scan()
        {
            while (_running)
            {
                var result = ReadPassiveTargetId(MifareIso14443A, _threadTimeout);
                if (result != null)
                {
                    var uid = "";
                    for (var i = 0; i < result.Length; i++)
                        uid += Common.ByteToHex(result[i]);
                    if (TagFound != null) TagFound(uid);
                }

                _threadWaitForStop.WaitOne(_threadPeriod, true);
                _threadWaitForStop.Reset();
            }
        }

        private byte[] ReadPassiveTargetId(byte baudrate, int timeout)
        {
            byte[] packet =
            {
                CommandInlistpassivetarget,
                1, // Activate only one target (max 2)
                baudrate
            };

            if (!SendCommandCheckAck(packet, timeout))
                return null;

            var response = ReadData(20);

            if (response[7] != 1) return null;

            DebugOnly.Print("Tag found!");

            var uid = new byte[response[12]];

            for (uint i = 0; i < response[12]; i++)
                uid[i] = response[13 + i];

            DebugOnly.Print("UID:");
            DebugOnly.PrintByteArray(uid);

            return uid;
        }

        private bool SamConfig()
        {
            byte[] packet =
            {
                CommandSamconfiguration,
                0x01, // normal mode;
                0x14, // timeout 50ms * 20 = 1 second
                0x01 // use IRQ pin!
            };

            if (!SendCommandCheckAck(packet))
                return false;

            var response = ReadData(8);

            return response[5] == 0x15;
        }

        // LOW LEVEL COMM
        private byte[] ReadData(int n)
        {
            var read = new byte[n + 1];

            byte[] write = {SpiDataread};
            write = Utility.CombineArrays(write, Common.CreateNullPayload(n));

            write = Common.ReverseBit(write);

            _spi.WriteRead(write, read);

            read = Utility.ExtractRangeFromArray(read, 1, n);
            read = Common.ReverseBit(read);

            // Debug informations
            DebugOnly.Print("\nReading response: ");
            DebugOnly.PrintByteArray(read);

            return read;
        }

        private void WriteCommand(byte[] cmd)
        {
            var cmdlen = (uint) cmd.Length + 1;

            // Compute checksum
            var checksum = Preamble + Preamble + Startcode + HostToPn532;

            for (uint i = 0; i < cmdlen - 1; i++)
                checksum += cmd[i];

            byte[] writeHeader =
            {
                SpiDatawrite,
                Preamble,
                Preamble,
                Startcode,
                (byte) cmdlen,
                (byte) (~cmdlen + 1),
                HostToPn532
            };

            byte[] writeFooter =
            {
                (byte) ~checksum,
                Postamble
            };

            // Create write array
            var write = Utility.CombineArrays(writeHeader, cmd);
            write = Utility.CombineArrays(write, writeFooter);

            write = Common.ReverseBit(write);

            _spi.Write(write);

            // Debug informations
            DebugOnly.Print("\nSending command: ");
            DebugOnly.PrintByteArray(write);
        }

        private bool ReadAck()
        {
            var read = ReadData(6);

            return Common.CompareByteArray(read, Ack);
        }

        private bool IsReady()
        {
            // SPI read status and check if ready.
            var read = new byte[1];
            byte[] write = {SpiStatread};

            write = Common.ReverseBit(write);

            _spi.Write(write);
            _spi.WriteRead(Common.CreateNullPayload(1), read);

            read = Common.ReverseBit(read);

            return read[0] == SpiReady;
        }

        private bool WaitReady(int timeout)
        {
            uint timer = 0;
            while (!IsReady())
            {
                if (timeout != 0)
                {
                    timer += 10;
                    if (timer > timeout)
                    {
                        DebugOnly.Print("ERROR: No response from PN532!");
                        return false;
                    }
                }

                Thread.Sleep(10);
            }

            DebugOnly.Print("PN532 is READY!");

            return true;
        }
    }
}